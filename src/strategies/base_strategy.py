"""
Base strategy module for Polymarket US trading bot.

This module defines the abstract base class and data structures that all
trading strategies inherit from. It provides a consistent interface for
signal generation and strategy lifecycle management.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timezone
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Optional

import structlog

from ..state.state_manager import MarketState, PositionState

logger = structlog.get_logger()


# =============================================================================
# Enums
# =============================================================================

class SignalAction(str, Enum):
    """Action type for trading signals."""
    BUY_YES = "BUY_YES"      # Buy YES shares (go long on outcome)
    SELL_YES = "SELL_YES"    # Sell YES shares
    BUY_NO = "BUY_NO"        # Buy NO shares (go short on outcome)
    SELL_NO = "SELL_NO"      # Sell NO shares
    CANCEL_ALL = "CANCEL_ALL"  # Cancel all orders for the market


class Urgency(str, Enum):
    """Urgency level for signal execution."""
    LOW = "LOW"        # Can wait, use limit orders
    MEDIUM = "MEDIUM"  # Execute soon, aggressive limit
    HIGH = "HIGH"      # Execute immediately, cross spread if needed


# =============================================================================
# Signal Dataclass
# =============================================================================

@dataclass(frozen=True)
class Signal:
    """
    Immutable trading signal generated by a strategy.
    
    Signals represent a trading intention that the StrategyEngine
    will convert into actual orders. Signals are immutable to ensure
    they can be safely passed around and logged.
    
    Attributes:
        market_slug: Market identifier
        action: Type of action (BUY_YES, SELL_YES, etc.)
        price: Target price for the order
        quantity: Number of contracts to trade
        urgency: How quickly the signal should be executed
        strategy_name: Name of the strategy that generated this signal
        confidence: Confidence level from 0.0 to 1.0
        reason: Human-readable explanation for the signal
        timestamp: When the signal was generated
        metadata: Optional additional data for logging/debugging
    
    Example:
        >>> signal = Signal(
        ...     market_slug="nba-lakers-vs-celtics",
        ...     action=SignalAction.BUY_YES,
        ...     price=Decimal("0.48"),
        ...     quantity=100,
        ...     urgency=Urgency.LOW,
        ...     strategy_name="market_maker",
        ...     confidence=0.8,
        ...     reason="Market making bid at 0.48",
        ... )
    """
    market_slug: str
    action: SignalAction
    price: Decimal
    quantity: int
    urgency: Urgency
    strategy_name: str
    confidence: float
    reason: str
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    metadata: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        """Validate signal parameters."""
        if self.quantity < 0:
            raise ValueError("Quantity must be non-negative")
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")
        if self.action != SignalAction.CANCEL_ALL:
            if self.price <= 0 or self.price >= 1:
                raise ValueError("Price must be between 0 and 1 (exclusive)")
    
    @property
    def is_buy(self) -> bool:
        """Check if this is a buy signal."""
        return self.action in (SignalAction.BUY_YES, SignalAction.BUY_NO)
    
    @property
    def is_sell(self) -> bool:
        """Check if this is a sell signal."""
        return self.action in (SignalAction.SELL_YES, SignalAction.SELL_NO)
    
    @property
    def is_cancel(self) -> bool:
        """Check if this is a cancel signal."""
        return self.action == SignalAction.CANCEL_ALL
    
    @property
    def side(self) -> str:
        """Get the side (YES or NO) this signal affects."""
        if self.action in (SignalAction.BUY_YES, SignalAction.SELL_YES):
            return "YES"
        return "NO"
    
    @property
    def notional_value(self) -> Decimal:
        """Calculate notional value of the signal."""
        return self.price * self.quantity
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for logging."""
        return {
            "market_slug": self.market_slug,
            "action": self.action.value,
            "price": float(self.price),
            "quantity": self.quantity,
            "urgency": self.urgency.value,
            "strategy_name": self.strategy_name,
            "confidence": self.confidence,
            "reason": self.reason,
            "timestamp": self.timestamp.isoformat(),
        }


# =============================================================================
# Base Strategy
# =============================================================================

class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Strategies generate trading signals based on market conditions.
    They are stateless regarding execution - they generate signals
    but don't execute orders directly.
    
    Subclasses must implement:
    - on_market_update(): Called when market prices update
    - on_tick(): Called periodically for time-based logic
    - name property: Returns the strategy name
    
    Example:
        >>> class MyStrategy(BaseStrategy):
        ...     @property
        ...     def name(self) -> str:
        ...         return "my_strategy"
        ...     
        ...     def on_market_update(self, market: MarketState) -> List[Signal]:
        ...         # Generate signals based on market state
        ...         return []
        ...     
        ...     def on_tick(self) -> List[Signal]:
        ...         # Generate signals based on time
        ...         return []
    """
    
    def __init__(self, enabled: bool = True):
        """
        Initialize base strategy.
        
        Args:
            enabled: Whether the strategy is active
        """
        self._enabled = enabled
        self._pending_signals: List[Signal] = []
        self._markets: Dict[str, MarketState] = {}
        self._positions: Dict[str, PositionState] = {}
        
        logger.info(
            "Strategy initialized",
            strategy=self.name,
            enabled=enabled,
        )
    
    # =========================================================================
    # Abstract Methods
    # =========================================================================
    
    @property
    @abstractmethod
    def name(self) -> str:
        """
        Get the strategy name.
        
        Returns:
            Unique identifier for this strategy
        """
        pass
    
    @abstractmethod
    def on_market_update(self, market: MarketState) -> List[Signal]:
        """
        Called when market prices update.
        
        This is the primary method for strategies to react to market changes.
        Strategies should analyze the market state and return any signals
        they want to generate.
        
        Args:
            market: Current market state with bid/ask prices
            
        Returns:
            List of signals to execute (can be empty)
        """
        pass
    
    @abstractmethod
    def on_tick(self) -> List[Signal]:
        """
        Called periodically for time-based logic.
        
        This method is called at regular intervals (e.g., every second)
        regardless of market updates. Use it for time-dependent logic
        like quote refreshing or position aging.
        
        Returns:
            List of signals to execute (can be empty)
        """
        pass
    
    # =========================================================================
    # Optional Override Methods
    # =========================================================================
    
    def on_position_update(self, position: PositionState) -> List[Signal]:
        """
        Called when a position changes.
        
        Override this method to react to position updates, such as
        when orders are filled or positions are closed.
        
        Args:
            position: Updated position state
            
        Returns:
            List of signals to execute (can be empty)
        """
        return []
    
    def on_order_filled(
        self,
        market_slug: str,
        filled_quantity: int,
        fill_price: Decimal,
    ) -> List[Signal]:
        """
        Called when an order is filled.
        
        Override this method to react to order fills, such as
        updating internal state or generating follow-up orders.
        
        Args:
            market_slug: Market where the order was filled
            filled_quantity: Number of contracts filled
            fill_price: Price at which the order was filled
            
        Returns:
            List of signals to execute (can be empty)
        """
        return []
    
    def start(self) -> None:
        """
        Called when the strategy is started.
        
        Override this method to perform initialization logic
        when the strategy begins running.
        """
        logger.info("Strategy started", strategy=self.name)
    
    def stop(self) -> None:
        """
        Called when the strategy is stopped.
        
        Override this method to perform cleanup logic
        when the strategy stops running.
        """
        logger.info("Strategy stopped", strategy=self.name)
    
    # =========================================================================
    # State Management
    # =========================================================================
    
    def update_market_state(self, market: MarketState) -> None:
        """
        Update cached market state.
        
        Args:
            market: New market state
        """
        self._markets[market.market_slug] = market
    
    def update_position_state(self, position: PositionState) -> None:
        """
        Update cached position state.
        
        Args:
            position: New position state
        """
        self._positions[position.market_slug] = position
    
    def get_market(self, market_slug: str) -> Optional[MarketState]:
        """
        Get cached market state.
        
        Args:
            market_slug: Market identifier
            
        Returns:
            MarketState if cached, None otherwise
        """
        return self._markets.get(market_slug)
    
    def get_position(self, market_slug: str) -> Optional[PositionState]:
        """
        Get cached position state.
        
        Args:
            market_slug: Market identifier
            
        Returns:
            PositionState if cached, None otherwise
        """
        return self._positions.get(market_slug)
    
    def get_all_markets(self) -> List[MarketState]:
        """
        Get all cached market states.
        
        Returns:
            List of all cached MarketState objects
        """
        return list(self._markets.values())
    
    def get_all_positions(self) -> List[PositionState]:
        """
        Get all cached position states.
        
        Returns:
            List of all cached PositionState objects
        """
        return list(self._positions.values())
    
    # =========================================================================
    # Properties
    # =========================================================================
    
    @property
    def enabled(self) -> bool:
        """Check if strategy is enabled."""
        return self._enabled
    
    @enabled.setter
    def enabled(self, value: bool) -> None:
        """Enable or disable the strategy."""
        self._enabled = value
        logger.info(
            "Strategy enabled state changed",
            strategy=self.name,
            enabled=value,
        )
    
    # =========================================================================
    # Helper Methods
    # =========================================================================
    
    def create_signal(
        self,
        market_slug: str,
        action: SignalAction,
        price: Decimal,
        quantity: int,
        urgency: Urgency = Urgency.LOW,
        confidence: float = 0.5,
        reason: str = "",
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Signal:
        """
        Create a signal from this strategy.
        
        Convenience method that automatically sets the strategy_name.
        
        Args:
            market_slug: Market identifier
            action: Signal action type
            price: Target price
            quantity: Number of contracts
            urgency: Execution urgency
            confidence: Confidence level (0.0 to 1.0)
            reason: Explanation for the signal
            metadata: Optional additional data
            
        Returns:
            New Signal instance
        """
        return Signal(
            market_slug=market_slug,
            action=action,
            price=price,
            quantity=quantity,
            urgency=urgency,
            strategy_name=self.name,
            confidence=confidence,
            reason=reason,
            metadata=metadata,
        )
    
    def create_cancel_signal(
        self,
        market_slug: str,
        reason: str = "Cancelling orders",
    ) -> Signal:
        """
        Create a cancel signal for a market.
        
        Args:
            market_slug: Market identifier
            reason: Explanation for cancellation
            
        Returns:
            New Signal with CANCEL_ALL action
        """
        return Signal(
            market_slug=market_slug,
            action=SignalAction.CANCEL_ALL,
            price=Decimal("0.50"),  # Dummy price for cancel
            quantity=0,
            urgency=Urgency.LOW,
            strategy_name=self.name,
            confidence=1.0,
            reason=reason,
        )
    
    def clamp_price(self, price: Decimal) -> Decimal:
        """
        Clamp price to valid range [0.01, 0.99].
        
        Args:
            price: Price to clamp
            
        Returns:
            Price clamped to valid range
        """
        return max(Decimal("0.01"), min(Decimal("0.99"), price))
    
    def __repr__(self) -> str:
        """String representation."""
        return f"<{self.__class__.__name__}(name={self.name}, enabled={self.enabled})>"
